## Go语言项目

所有的编程语言都反映了设计者对编程哲学的反思, 通常包括之前的语言所暴露的一些不足的地方.
Go项目是在Google超级复杂的几个软件系统遇到的一些问题的反思(但是这个问题绝不是谷歌特有的).

正如Rob Pike所说, “复杂性是乘法级相关的”, 通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性. 通过增加功能和选项和配置是修复问题的最快的途径, 但是这很容易忽略简洁的内涵, 即使从长远来看, 简洁依然是好的软件关键因素.

简洁需要在工作开始的时候减少不必要的想法, 并且在软件的生命周期内严格区别好的改变或坏的改变. 通过足够的努力, 一个好的改变可以在不破坏完整概念的前提下保持自适应, 正如 Fred Brooks 所说的 "概念完整性"; 而一个坏的改变则不能, 它们仅仅是通过肤浅的简单的妥协来破坏设计的一致性. 只有通过简洁的设计, 才能让一个系统保持稳定, 安全, 和持续的生长.

Go项目包括语言本身, 附带的工具和标准库, 最后但并非不重要的, 简洁编程哲学的宣言. 就事后的目光来看, Go的这些地方都做的不错: 拥有自动垃圾回收, 一个包系统, 函数作为一等公民, 词法作用域, 系统调用接口, 只读的UTF8字符串. 但是Go只有相对较少的特性, 也不太可能对添加更多. 例如, 它没有隐式的数值转换, 没有构造函数和析构函数, 没有运算符重载, 没有默认参数, 没有继承, 没有泛型, 没有异常, 没有宏, 没有函数修饰, 没有线程局部存储. 但是语言是成熟和稳定的, 而且保证向后兼容: 以前的Go程序可以用新版本的编译器和标准库下构建.

Go有足够的类型系统以避免动态语言中那些粗心的类型错误, 但是Go的类型系统相比传统的强类型语言又要简洁很多. 有时候这会导致一个"无类型"的抽象类型, 但是Go程序员并不需要像 C++ 或 Haskell 程序员那样纠结具体类型的安全属性. 但实践中Go的简洁的类型系统给了程序员更多的安全性和更好的运行时性能.

Go 鼓励当代计算机系统设计的认识, 特别是局部的重要性. 它的内置数据类型和大多数的准库数据结构都经过精心设计而避免显式的初始化或隐式的构造函数, 因此较少的内存分配和内存初始化被隐藏在了代码中. Go的聚合类型(结构体和数组)直接操作它们的元素, 需要更少的存储空间, 更少的内存分配, 而且指针操作比其他间接语言也更直接. 由于现代计算机是一个并行的机器, Go提供了基于CSP的并发特性. Go的动态栈使得轻量级线程goroutine的初始栈很小, 创建一个goroutine的代价很小, 因此创建百万级的goroutine是可行的.

Go的标准库(通常被称为自带的电池), 提供了清晰的构建模块和接口, 包含 I/O, 文本处理, 图像, 密码学, 网络, 和分布式应用程序, 并支持许多标准的文件格式和协议. 库和工具使用大量的约定来减少额外的配置和解释, 从而简化程序的逻辑, 而且每个Go程序结构都是如此的相似, 因此也更容易学习. 构建项目使用的Go工具只使用文件名和标识符名称, 一个偶尔的特殊注释来确定所有的库, 可执行文件, 测试, 基准测试, 例子, 特定于平台的变量, 项目的文档; Go源代码本身包含构建规范.

