### 2.4.2. 可赋值性

赋值语句是显示的赋值形式, 但是程序中还有很多地方会发送隐式的赋值行为: 函数调用将隐式地将调用参数的值赋值给函数的参数变量, 一个返回语句将隐式地将返回操作的值赋值给结果变量, 一个复合类型的字面量(§4.2)也会产生赋值行为. 例如下面的语句:

```Go
medals := []string{"gold", "silver", "bronze"} 
```

隐式地对切片的每个元素进行赋值操作, 类似这样写的行为:

```Go
medals[0] = "gold" 
medals[1] = "silver" 
medals[2] = "bronze" 
```

字典和管道的元素, 虽然不是普通的变量, 但是也有类似的隐式赋值行为.

不管是隐式还是显示地赋值, 在赋值语句坐标的变量和右边最终的求到的值必须有相同的数据类型. 更直白地说, 只有右边的值对于左边的变量是可赋值的, 赋值语句才是允许的.

可赋值性的规则对于不同类型有不同要求, 对每个新类型有关的地方我们会专门解释.
对于目前我们已经讨论过的类型, 它的规则是简单的: 类型必须完全匹配, nil 可以赋值给任何指针或引用类型的变量. 常量(§3.6)有更灵活的规则, 这样可以避免不必要的显示类型转换.

对于两个值是否可以用 `==` 或 `!=` 进行相等比较的能力也和可赋值能力有关系:
对于任何的比较, 第一个操作必须是可用于第二个操作类型的变量的赋值的, 反之依然.
和前面一样, 我们会对每个新类型比较有关的地方会做专门解释.


