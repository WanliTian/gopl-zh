### 2.3.4. 变量的生命周期

变量的生命周期指的是程序运行期间变量存在的有效时间间隔. 包级声明的变量的生命周期和程序的生命周期是一致的. 相比之下, 局部变量的声明周期是动态的: 从每次创建一个新变量的声明语句被执行开始, 直到变量不在被引用为止, 然后变量的存储空间可能被回收. 函数的参数变量和返回值变量都是局部变量. 它们在函数每次被调用的时候创建.

例如, 下面是从 1.4 节的 Lissajous 程序摘录的代码片段:

```Go
for t := 0.0; t < cycles*2*math.Pi; t += res { 
	x := math.Sin(t) 
	y := math.Sin(t*freq + phase) 
	img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), 
		blackIndex) 
} 
```

在每次循环的开始创建变量 t, 然后在每次循环迭代中创建 x 和 y.

那么垃圾收集器是如何知道一个变量是何时可以被回收的呢? 这里我们先避开完整的技术细节, 但是基本的思路是, 从每个包级的变量和每个当前运行函数的每一个局部变量开始, 通过指针或引用的路径, 是否可以找到该变量. 如果不存在这样的路径, 那么说明该变量是不可达的, 也就是说它并不会影响其余的计算.

因为一个变量的声明周期只取决于是否可达, 因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域. 它可能在函数返回之后依然存在.

编译器会选择在栈上还是在堆上分配局部变量的存储空间, 但可能令人惊讶的是, 这个选择并不是由 var 或 new 来决定的.

```Go
var global *int 

func f() {                 func g() { 
	var x int                  y := new(int) 
	x = 1                      *y = 1 
	global = &x            } 
} 
```

这里的 x 必须在堆上分配, 因为它在函数退出后依然可以通过包的 global 变量找到, 虽然它是在函数内部定义的; 我们说这个 x 局部变量从 函数 f 中逃逸了. 相反, 当 g 函数返回时, 变量 `*y` 将是不可达的, 也就是可以被回收的. 因此, `*y` 并没有从 函数 g 逃逸, 编译器可以选择在栈上分配 `*y` 的存储空间, 虽然这里用的是 new 方式.
在任何时候, 你并不需为了编写正确的代码而要考虑变量的逃逸行为, 要记住的是, 逃逸的变量需要额外分配内存, 同时对性能的优化会产生一定的影响.

垃圾收集器对编写正确的代码是一个巨大的帮助, 但并不是说你完全不用考虑内存了. 你虽然不需要显式地分配和释放内存, 但是要编写高效的程序你还是需要知道变量的生命周期. 例如, 将指向短生命周期对象的指针保存到具有长生命周期的对象中, 特别是全局变量时, 会阻止对短生命周期对象的垃圾回收.


 
