## 2.7. 作用域

一个声明语句将程序中的实体和一个名字关联, 比如一个函数或一个变量. 声明的作用域是指源代码中可以有效使用这个名字的范围.

不要将作用域和生命周期混为一谈. 声明的作用域对应的是一个源代码的文本区域; 它是一个编译时的属性. 一个变量的生命周期是程序运行时变量存在的有效时间段, 在此时间区域内存它可以被程序的其他部分引用. 是一个运行时的概念.

语法块是由花括弧所包含的一系列语句, 就像函数体或循环体那样. 语法块内部声明的名字是无法被外部语法块访问的. 语法决定了内部声明的名字的作用域范围. 我们可以这样理解, 语法块可以包含其他类似组批量声明等没有用花括弧包含的代码, 我们称之为词汇块. 有一个语法决为整个源代码, 称为全局块; 然后是每个包的语法决; 每个 for, if 和 switch 语句的语法决; 每个 switch 或 select 分支的 语法决; 当然也包含显示编写的语法块(花括弧包含).

声明的词法域决定了作用域范围是大还是小. 内置的类型, 函数和常量, 比如 int, len 和 true 等是在全局作用域的, 可以在整个程序中直接使用. 任何在在函数外部(也就是包级作用域)声明的名字可以在同一个包的任何Go文件访问. 导入的包, 例如 tempconv 导入的 fmt 包, 则是对应文件级的作用域, 因此只能在当前的文件中访问 fmt 包, 当前包的其它文件无法访问当前文件导入的包. 还有许多声明, 比如 tempconv.CToF 函数中的变量 c, 则是局部作用域的, 它只能在函数内部(甚至只能是某些部分)访问.

控制流标签, 例如 break, continue 或 goto 后面跟着的那种标签, 则是函数级的作用域.

一个程序可能包含多个同名的声明, 只有它们在不同的词法域就没有关系. 例如, 你可以声明一个局部变量, 和包级的变量同名. 或者是 2.3.3节的那样, 你可以将一个函数参数的名字声明为 new, 虽然内置的new是全局作用域的. 但是物极必反, 如果滥用重名的特性, 可能导致程序很难阅读.

当编译器遇到一个名字引用, 它看起来像一个声明, 它首先从最内层的词法域向全局的作用域查找. 如果查找失败, 则报告 "未声明的名字" 这样的错误. 如果名字在内部和外部的块分别声明, 则内部块的声明首先被找到. 在这种情况下, 内部声明屏蔽了外部同名的声明, 让外部的声明无法被访问:

```Go
func f() {} 

var g = "g" 

func main() { 
	f := "f" 
	fmt.Println(f) // "f"; local var f shadows package-level func f 
	fmt.Println(g) // "g"; package-level var 
	fmt.Println(h) // compile error: undefined: h 
} 
```

TODO
